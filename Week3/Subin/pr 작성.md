# 📌 문제 설명
문제 입력 :  지도의 한 변 크기 n과 2개의 정수 배열 arr1, arr2가 들어온다.

출력 형식: 원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.

문제 출력 : n=5,arr1=[9,20,28,18,11],arr2=[30,1,21,17,28])  => ["#####","# # #", "### #", "# ##", "#####"]

주요 조건들 : 1<=n<=16/ arr1, arr2는 길이 n인 정수 배열로 주어진다. / 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.

# 📌 문제 접근법
위에 그림을 보며 이진수로 바꾸어 비트연산을 해야겠다고 생각했다.
OR비트연산자를 이용해 2진수를 비교했고, 0을 공백으로 1을 #으로 바꾸었다. 그런데 비트연산자는 앞에 0들은 제거하여 길이가 달라지는 문제가 생겨서 0을 추가하는 함수를 넣었다. 
(찾아보니 2진수 변환 후 길이를 맞추어주는 zfill(n) 함수도 있었다.)

# 📌 풀이 결과
<img width="319" alt="image" src="https://github.com/user-attachments/assets/be3b24d0-2c40-42d8-aa70-9df3017a6282">

